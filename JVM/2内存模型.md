### 运行时数据区

方法区、堆、虚拟机栈、本地方法栈、程序计数器

![](E:\workspace\study\StudyNote\JVM\pic\运行时数据区.png)

1. 程序计数器

   一块较小的内存空间，用于指定程序执行下一条需要执行的字节码指令（我理解为相当于汇编语言中所讲的CS:IP，用于指定当前执行语句在内存中的位置），java多线程是通过轮流切换线程并分配处理器执行时间，所以该内存为线程私有，每个线程都有一个程序计数器；当执行的是java方法，返回的是该代码在内存中的地址，当执行的是native本地方法，返回的值是空（Undefined）；是唯一一个在虚拟机中没有规定任何OutofMenmoryError的内存区域

2. java虚拟机栈

   是虚拟机内java方法执行内存模型，每个方法都会创建一个栈帧，进行入栈出栈操作就相当于一个方法的执行过程，栈帧存放着方法内部的变量表、操作数栈、动态链接、方法出口等

   局部变量表放置了编译期确定的各种基本类型、对象引用和返回的下一个执行语句的地址，这些都是在编译期就确定的，其中一个4字节长度为一个Slot单元，比如double和long这种8字节用两个Slot单元表示，且两个Slot不能单独访问

   如果请求需要的栈深度大于虚拟机栈深度，会报出StackOverflowError异常；假如可以动态扩展，在达到最大栈深度时进行扩展，在扩展时内存不足的话，会抛出OutOfMemoryError异常

3. 本地方法栈

   本地方法栈和虚拟机栈类似，只不过是用来执行Native方法的栈

4. 堆

   存放着几乎所有的对象实例，是垃圾收集器（GC）主要工作的区域；在虚拟机启动时创建，各个线程所共享的区域。可细分为新生代和老年代；内存不足以后会抛出OutOfMemoryError

5. 方法区

   用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；虚拟机规范描述为堆的一个逻辑部分，也被叫做永久代，垃圾收集器在这里比较少出现，(--XX:MaxPermSize)

6. 运行时常量池

   是方法区的一部分，用于存储一些编译器生成的各种字面量的引用，在类加载后进入运行时常量池，运行期间也可以生成，比较多的方式就是String.intern()

7. 直接内存

   不是java虚拟机管理的内存，jdk1.4引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据

   不受java堆大小的限制，受物理机内存和swap分区的限制，当扩展时需要的内存大于物理机内存，抛出OutOfMemoryError异常

#### 对象的创建

- 虚拟机遇到new指令时，先去常量池中获取类的符号引用，检查类是否已被加载，未加载则需先执行类加载过程

- 为新生对象分配内存，并初始化零值

  内存分配方式：

  ​	指针碰撞：堆内存规整时，将指针向空闲区域挪动一个对象的位置；采用带有压缩整理功能的垃圾收集器

  ​	空闲列表：维护一个列表记录可用内存，然后找到足够大的内存分配给对象

  new对象的线程安全：CAS配上失败重试的方式保证原子性；通过本地线程分配缓冲（TLAB），在线程内的内存上分配，只有当内存需要扩展时才需要同步锁定，可用-XX:+/-UseTLAB

  内存分配完后，将内存空间初始化为零值

- 对对象进行必要的设置

  设置对象的基本信息（Object Header）

- 调用init方法初始化对象

#### 对象的内存布局

- 对象头

  这部分数据长度在32为和64为虚拟机上分别为32bit和64bit，叫做Mark Word

  ![1570456333372](.\pic\1570456333372.png)

- 实例数据

- 对齐填充

  非必须，保证字节长度为8的整数倍

#### 对象访问定位

- 句柄访问![1570456574876](.\pic\1570456574876.png)
- 直接访问![1570456607429](.\pic\1570456607429.png)