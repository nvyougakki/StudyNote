#   垃圾收集和内存管理

### 对象是否可以回收

- **引用计数法**

  给对象添加引用计数器，一个地方引用，加1；引用失效，减1；效率高但无法回收相互引用的对象

- **可达性分析算法**

  通过一系列称为GC Roots作为对象的起点，从结点开始向下搜索，走过的路径称为引用链，当一个对象没有到GC Roots的引用链，则对象不可用

  java中的引用链：

  - 虚拟机栈中引用的对象（执行方法中引用的对象）
  - 方法区中类静态属性引用的常量
  - 方法区中常量引用的对象
  - 本地方法栈引用的对象
  
- **回收方法区**

  方法区主要存放着常量和类信息，所以回收也就是针对常量和类信息进行回收

  - 常量回收

    没有任何地方引用到该常量，在发生垃圾回收时，如果有必要，进行回收

  - 类回收

    该类所以的实例都被回收

    加载该类的类加载器被回收

    该类的Class对象未被引用，且无法通过反射访问该类的方法

### 垃圾收集算法：

- 标记清除算法

  效率不高

  产生大量不连续的内存碎片，内存碎片太多将导致大对象分配时由于无法找到足够连续的内存区域而再次触发垃圾收集

- 标记整理算法

  使用于老年代，是让所有存活的对象向一端移动，然后清除边界外的内存区域

- 复制算法

  将内存区域分为两块，进行收集时候将一个内存中存活的对象复制到另一个内存中

  实现简单、运行高效，但浪费空间

### HotSpot算法实现

- 枚举根节点

- 安全点

- 安全区域

### 垃圾收集器

- Serial收集器

  发展历史最悠久的收集器，由于是单线程收集器，只会使用一个CPU或一条线程进行收集，在收集时候需要暂停其他所有线程（Stop The World），

- ParNew收集器

  Serial收集器的多线程版本，是许多运行在Server模式下虚拟机中的收集器，除了Serial外，只有它能和CMS合作，如果老年代选择了CMS收集器，则年轻代默认是ParNew

  JVM参数：-XX:+UseParNewGC或-XX:+UseConcMarkSweepGC

- Parallel Scavenge收集器

  多线程，采用复制算法的新生代收集器

  主要针对要求垃圾收集时候尽可能的减少停顿时间，吞吐量=运行代码时间/(运行代码时间+垃圾收集时间)；

  通过-XX:MaxGCPauseMillis控制最大收集时间和-XX:GCTimeRatio控制吞吐量

  通过-XX:UserAdaptiveSizePolicy，打开功能后 虚拟机会根据当前运行状态自动设置合适的停顿时间和最大吞吐量

- Serial Old收集器

- Parallel Old收集器

- ***CMS收集器***

- ***G1收集器***

  ![1576028081376](pic\1576028081376.png)